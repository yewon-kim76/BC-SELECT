colSums2<-function(X){
  if (class(X)=="numeric") y=X
  if (class(X)=="matrix") y=colSums(X,na.rm=T)
  return(y)}


qnorm.array <- function(mat)    
{mat.back = mat 
	mat = mat[!is.na(mat)]
    mat = rank(mat, ties.method = "average");
    mat = qnorm(mat / (length(mat)+1));
    mat.back[!is.na(mat.back)] = mat 
    mat.back}


rank.array <- function(mat)    
{mat.back = mat 
	mat = mat[!is.na(mat)]
    mat = rank(mat, ties.method = "average")/length(mat);
    mat.back[!is.na(mat.back)] = mat 
    mat.back}


phylo.profile = function(sr.gene.all){ # Phylogenetic profiling
	sr.gene1 = sr.gene.all
	sr.phylo =  cbind(match(sr.gene1$rescuer, phylo$genes), match(sr.gene1$vulnerable, phylo$genes))
	featureMat = (phylo[sr.phylo[,1],-(1:3)] - phylo[sr.phylo[,2],-(1:3)])^2
	featureMat=as.matrix(featureMat)
	class(featureMat) <- "numeric"	
	featureMat %*% t(feature.weight)}


rank.norm= function(ss) {
	out = rank(ss, na.last="keep")/max(1, sum(!is.na(ss)))
	out[is.na(out)] = 1
	out}


getAUC <- function(pval,flag){
	na.inx=which(!is.na(flag) & !is.na(pval))
	pval=pval[na.inx]
	flag=flag[na.inx]
	pred <- prediction(pval, flag) # library(ROCR)
	perf <- performance(pred,"auc")
	auc=perf@y.values[[1]][1] # Area under the ROC Curve
	
	perf1 <- performance(pred, measure="prec", x.measure="rec")
	rec=perf1@x.values[[1]]
	prec=recall=perf1@y.values[[1]]
	prr <- trapz(rec[2:length(rec)], prec[2:length(prec)]) # library(pracma), Area under the PR ROC Curve
	return(c(auc,prr))}

bin_matrix <- function(x, direction = "row", bin = TRUE, split = 3) {
  if (direction == "column") {
    rank_norm <- apply(x, 2, rank.array)
    if (split == 2) {q2 <- 1 * (rank_norm >= 1 / 2)}
    if (split == 3) {q2 <- 1 * (rank_norm > 1 / 3) + 1 * (rank_norm > 2 / 3)}
  }
  if (direction == "row") {
    rank_norm <- t(apply(x, 1, rank.array))
    if (split == 2) {q2 <- 1 * (rank_norm >= 1 / 2)}
    if (split == 3) {q2 <- 1 * (rank_norm > 1 / 2) + 1 * (rank_norm > 2 / 3)}
  }
  if (bin == TRUE) {return(q2)}
  if (bin == FALSE) {return(rank_norm)} }

# Count up/down regulated genes for normalized SR score
down_counts <- function(x){ifelse(x < 0.33, 1, 0)} # Check the down-regulated gene 
up_counts <- function(x){ifelse(x > (1-0.33), 1, 0)} # Check the up-regulated gene 


# Identify the SR partner genes among those listed in NanoString
sr.find.dd <- function(sr.final1){
  sl.res=NA; FDR=0.2; flag=1   # step I: hypergeometric 
  hyper <- apply(sr.final1[,c(3,4,5)], 2, function(x) p.adjust (x, method = "BH")) # Multiple testing correction
  colnames(hyper) <- c("BH_pval.mRNA1_2" ,  "BH_pval.mRNA1_3" , "BH_pval.mRAN.up_1")
  sr.final1 <- cbind(sr.final1, hyper)
  iy = which(apply(hyper, 1, min)< FDR) # Adjusted p-value with BH method length(iy) 
  
  if (length(iy)>1) {
  flag=2
  sr.final1 = sr.final1[iy,] # step II: survival 
  clinical.fdr2 = apply(sr.final1[,c(7,9)], 2, function(x) p.adjust (x, method = "BH")) # P-value for two datasets 
  colnames(clinical.fdr2) <- c("BH_bb_pvalue_tcga", "BH_bb_pvalue_meta")  # Multiple testing correction
  sr.final1 <- cbind(sr.final1, clinical.fdr2) # Save survival analysis results 
  iz = which(rowSums(clinical.fdr2 < FDR ) >= 1) # Adjusted p-value with BH method length(iz)
    
  if (length(iz)>1) {
  flag=3
  sr.final1=sr.final1[iz,] # step III: phylogenetic 
  ix=which(sr.final1[,10] < 2.315712e+01 | sr.final1[,11] < 2.315712e+01 ) # Based on PDCD1, CD274 scores
  sr.final1=sr.final1[ix,]}}
  if (flag==3) sl.res=sr.final1
  return(sl.res)}

# Rank the SR partner genes according to their phylogenetic similarity score		
sr.ranking.dd <-function(sr.final1){
  ps1 = sr.final1[,10] ; ps2 = sr.final1[,11] 								
  ps = ifelse(ps1 >= ps2, ps2, ps1) # Prefer genes with the smallest distance	
  ii = order(ps,decreasing = FALSE) # Sort phylogenetic distance
  return(ii)}

# Assign SR scores to each patient using the identified SR partner genes			
sr.score.dd <- function(dat, sr.final1){
  score1 = rep(0,ncol(dat$mRNA))	
  partners1 = match(sr.final1[,2], dat$genes)
  partners1 = partners1[!is.na(partners1)]
  if (length(partners1)==1) 
    score1=1*(dat$mRNA.rank2[partners1,] < 0.33)
  if (length(partners1) >1) 
    score1=colSums(dat$mRNA.rank2[partners1,] < 0.33, na.rm=T)/length(partners1) # Proportion of DD partner genes -> cancer cell survival
  score1=1-score1		# 1-score -> p(cancer cell death or drug response)
  return(score1)}


# Calculate updated SR scores by normalizing the SR score			
new.sr.score.dd <- function(dat, sr.final1){
  score1 = rep(0,ncol(dat$mRNA))	
  partners1 = match(sr.final1[,2], dat$genes)
  partners1 = partners1[!is.na(partners1)]
  if (length(partners1)==1)
    score1=1*(dat$mRNA.rank2[partners1,] < 0.33) 
  if (length(partners1) >1)
    score1=colSums(dat$mRNA.rank2[partners1,] < 0.33, na.rm=T)/length(partners1) 
  
  sub_gene <- intersect(nanostring, rownames(dat$mRNA)) ## Nanostring gene list 
  new_data <- dat$mRNA[rownames(dat$mRNA) %in% sub_gene,]
  new_data2 <- bin_matrix(new_data, direction = "row", bin = FALSE)
  new_data2 <- na.omit(new_data2)  # Remove NA
  whole_down <- apply(new_data2, 2 , down_counts)
  whole_down_patient <- as.numeric(colSums(whole_down))  # Count the down-regulated gene for each patient
  whole_score <- whole_down_patient / dim(new_data2)[1] # Whole SR scores for each patient
 
  new_score = (1- score1)/ (1-whole_score) # Normalize SR score
  
  return(new_score)}


# Save the results			
eval.auc.dd = function(sr.final, dat, ires1, iirs1){# Target gene expression = PD1/PDL1
  res = NULL
  sr.x = cbind(genes[sr.final[,1]],genes[sr.final[,2]]) # Bring identified SR partners
  score1 = new.sr.score.dd(dat, sr.x) # Normalizd SR score
  a <- which(rownames(dat$mRNA) == "PDCD1"); b <- which(rownames(dat$mRNA) == "CD274") # Target genes
  target <- as.numeric(dat$mRNA[a,])*as.numeric(dat$mRNA[b,]) # Simple product
  pval = score1[c(ires1,iirs1)] # Reorder normalized SR score
  target = target[c(ires1,iirs1)] # Reorder target gene expression
  flag = c(rep(1,length(ires1)),rep(0,length(iirs1))) # True drug response (pCR)
  res$score = pval; res$flag=flag # Normalized SR scores
  res$score2 = pval*rank.norm(target) # BC-SELECT scores
  res$score3 = rank.norm(target) # Rank normalized target expression
  res$sr.x=sr.x
  return(res)}


# For Monte Carlo experiment random sampling genes (required reordering during simulation)----
null_sr.score <- function(dat, null_genes){
  score1=rep(0,ncol(dat$mRNA))	
  partners1=match(null_genes, dat$genes)
  partners1=partners1[!is.na(partners1)]
  if (length(partners1)==1) 
    score1=1*(dat$mRNA.rank2[partners1,] < 0.33) ## mRNA.rank2 -> required bin-matrix
  if (length(partners1) >1) 
    score1=colSums(dat$mRNA.rank2[partners1,] < 0.33, na.rm=T)/length(partners1) # f (SELECT notation)
  
  score1 = 1- score1	# 1-f (SELECT notation)
  return(score1)}

# Function to identify target gene expression in evaluation data
target_value <- function(dat){
  a <- which(rownames(dat$mRNA) == "PDCD1"); b <- which(rownames(dat$mRNA) == "CD274") # Target genes
  target <- as.numeric(dat$mRNA[a,])*as.numeric(dat$mRNA[b,]) # Simple product
  return(target)}

